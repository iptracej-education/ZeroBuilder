"""
Comprehensive Vulnerability Pattern Database
Collects vulnerable calls, safe alternatives, and mitigation patterns
"""

from typing import Dict, List, Set, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import re

class VulnerabilityType(Enum):
    BUFFER_OVERFLOW = "buffer_overflow"
    INTEGER_OVERFLOW = "integer_overflow"
    USE_AFTER_FREE = "use_after_free"
    DOUBLE_FREE = "double_free"
    NULL_POINTER_DEREF = "null_pointer_deref"
    FORMAT_STRING = "format_string"
    COMMAND_INJECTION = "command_injection"
    RACE_CONDITION = "race_condition"
    MEMORY_LEAK = "memory_leak"
    UNINITIALIZED_MEMORY = "uninitialized_memory"

@dataclass
class VulnerabilityPattern:
    """Represents a vulnerability pattern with context"""
    function_name: str
    vulnerability_type: VulnerabilityType
    risk_level: float  # 0.0 = safe, 1.0 = always vulnerable
    context_required: List[str]  # Additional context needed
    description: str
    example_vulnerable: str
    example_safe: str

@dataclass
class MitigationPattern:
    """Represents a mitigation or safe alternative"""
    safe_function: str
    replaces_vulnerable: List[str]
    mitigation_type: str  # 'replacement', 'wrapper', 'validation'
    effectiveness: float  # 0.0-1.0 how effective the mitigation is
    description: str

class VulnerabilityPatternDatabase:
    """Comprehensive database of vulnerability patterns and mitigations"""
    
    def __init__(self):
        self.vulnerable_patterns = self._build_vulnerable_patterns()
        self.safe_patterns = self._build_safe_patterns()
        self.mitigation_patterns = self._build_mitigation_patterns()
        self.library_mitigations = self._build_library_mitigations()
        
    def _build_vulnerable_patterns(self) -> List[VulnerabilityPattern]:
        """Build comprehensive list of vulnerable function patterns"""
        return [
            # BUFFER OVERFLOW PATTERNS
            VulnerabilityPattern(
                function_name="strcpy",
                vulnerability_type=VulnerabilityType.BUFFER_OVERFLOW,
                risk_level=0.9,
                context_required=["unchecked_source", "fixed_destination"],
                description="Copies string without bounds checking",
                example_vulnerable="strcpy(dest, user_input);",
                example_safe="strncpy(dest, user_input, sizeof(dest)-1); dest[sizeof(dest)-1] = '\\0';"
            ),
            VulnerabilityPattern(
                function_name="sprintf",
                vulnerability_type=VulnerabilityType.BUFFER_OVERFLOW,
                risk_level=0.85,
                context_required=["format_string", "fixed_buffer"],
                description="Formats string without bounds checking",
                example_vulnerable="sprintf(buf, \"%s\", user_input);",
                example_safe="snprintf(buf, sizeof(buf), \"%s\", user_input);"
            ),
            VulnerabilityPattern(
                function_name="gets",
                vulnerability_type=VulnerabilityType.BUFFER_OVERFLOW,
                risk_level=1.0,
                context_required=[],
                description="Reads line with no bounds checking - always vulnerable",
                example_vulnerable="gets(buffer);",
                example_safe="fgets(buffer, sizeof(buffer), stdin);"
            ),
            VulnerabilityPattern(
                function_name="strcat",
                vulnerability_type=VulnerabilityType.BUFFER_OVERFLOW,
                risk_level=0.8,
                context_required=["unchecked_source", "existing_content"],
                description="Concatenates without checking destination size",
                example_vulnerable="strcat(dest, user_input);",
                example_safe="strncat(dest, user_input, sizeof(dest) - strlen(dest) - 1);"
            ),
            VulnerabilityPattern(
                function_name="vsprintf",
                vulnerability_type=VulnerabilityType.BUFFER_OVERFLOW,
                risk_level=0.9,
                context_required=["va_list", "fixed_buffer"],
                description="Variable argument sprintf without bounds",
                example_vulnerable="vsprintf(buf, fmt, args);",
                example_safe="vsnprintf(buf, sizeof(buf), fmt, args);"
            ),
            
            # MEMORY MANAGEMENT PATTERNS
            VulnerabilityPattern(
                function_name="malloc",
                vulnerability_type=VulnerabilityType.MEMORY_LEAK,
                risk_level=0.6,
                context_required=["missing_free", "error_paths"],
                description="Memory allocation without corresponding free",
                example_vulnerable="ptr = malloc(size); // no free on error path",
                example_safe="ptr = malloc(size); if (error) { free(ptr); return; }"
            ),
            VulnerabilityPattern(
                function_name="free",
                vulnerability_type=VulnerabilityType.DOUBLE_FREE,
                risk_level=0.7,
                context_required=["already_freed", "null_check"],
                description="Freeing already freed or NULL pointer",
                example_vulnerable="free(ptr); free(ptr);",
                example_safe="if (ptr) { free(ptr); ptr = NULL; }"
            ),
            VulnerabilityPattern(
                function_name="realloc",
                vulnerability_type=VulnerabilityType.MEMORY_LEAK,
                risk_level=0.5,
                context_required=["null_return", "original_pointer"],
                description="Realloc can return NULL, losing original pointer",
                example_vulnerable="ptr = realloc(ptr, new_size);",
                example_safe="temp = realloc(ptr, new_size); if (temp) ptr = temp; else free(ptr);"
            ),
            
            # INTEGER OVERFLOW PATTERNS
            VulnerabilityPattern(
                function_name="memcpy",
                vulnerability_type=VulnerabilityType.BUFFER_OVERFLOW,
                risk_level=0.7,
                context_required=["unchecked_size", "user_controlled_size"],
                description="Memory copy with unchecked size parameter",
                example_vulnerable="memcpy(dest, src, user_size);",
                example_safe="if (user_size <= sizeof(dest)) memcpy(dest, src, user_size);"
            ),
            VulnerabilityPattern(
                function_name="alloca",
                vulnerability_type=VulnerabilityType.BUFFER_OVERFLOW,
                risk_level=0.8,
                context_required=["large_allocation", "user_controlled_size"],
                description="Stack allocation with user-controlled size",
                example_vulnerable="ptr = alloca(user_size);",
                example_safe="if (user_size < MAX_STACK) ptr = alloca(user_size); else ptr = malloc(user_size);"
            ),
            
            # FORMAT STRING PATTERNS
            VulnerabilityPattern(
                function_name="printf",
                vulnerability_type=VulnerabilityType.FORMAT_STRING,
                risk_level=0.9,
                context_required=["user_controlled_format"],
                description="Printf with user-controlled format string",
                example_vulnerable="printf(user_input);",
                example_safe="printf(\"%s\", user_input);"
            ),
            VulnerabilityPattern(
                function_name="fprintf",
                vulnerability_type=VulnerabilityType.FORMAT_STRING,
                risk_level=0.9,
                context_required=["user_controlled_format"],
                description="Fprintf with user-controlled format string",
                example_vulnerable="fprintf(stderr, user_input);",
                example_safe="fprintf(stderr, \"%s\", user_input);"
            ),
            
            # COMMAND INJECTION PATTERNS
            VulnerabilityPattern(
                function_name="system",
                vulnerability_type=VulnerabilityType.COMMAND_INJECTION,
                risk_level=0.95,
                context_required=["user_input", "shell_metacharacters"],
                description="System call with user-controlled input",
                example_vulnerable="system(user_command);",
                example_safe="// Use execv() with argument array instead"
            ),
            VulnerabilityPattern(
                function_name="popen",
                vulnerability_type=VulnerabilityType.COMMAND_INJECTION,
                risk_level=0.9,
                context_required=["user_input", "shell_metacharacters"],
                description="Popen with user-controlled command",
                example_vulnerable="popen(user_command, \"r\");",
                example_safe="// Validate and sanitize command, use execv if possible"
            ),
            
            # CONCURRENCY PATTERNS
            VulnerabilityPattern(
                function_name="access",
                vulnerability_type=VulnerabilityType.RACE_CONDITION,
                risk_level=0.7,
                context_required=["toctou", "file_operation"],
                description="Time-of-check-time-of-use race condition",
                example_vulnerable="if (access(file, R_OK) == 0) fd = open(file, O_RDONLY);",
                example_safe="fd = open(file, O_RDONLY); if (fd < 0) handle_error();"
            ),
        ]
    
    def _build_safe_patterns(self) -> List[VulnerabilityPattern]:
        """Build list of safe function patterns"""
        return [
            # SAFE STRING FUNCTIONS
            VulnerabilityPattern(
                function_name="strncpy",
                vulnerability_type=VulnerabilityType.BUFFER_OVERFLOW,
                risk_level=0.1,
                context_required=["null_termination_check"],
                description="Bounded string copy (but check null termination)",
                example_vulnerable="strncpy(dest, src, n); // may not null terminate",
                example_safe="strncpy(dest, src, n-1); dest[n-1] = '\\0';"
            ),
            VulnerabilityPattern(
                function_name="snprintf",
                vulnerability_type=VulnerabilityType.BUFFER_OVERFLOW,
                risk_level=0.05,
                context_required=["return_value_check"],
                description="Bounded sprintf (check return value for truncation)",
                example_vulnerable="snprintf(buf, size, fmt, args); // ignore return",
                example_safe="ret = snprintf(buf, size, fmt, args); if (ret >= size) handle_truncation();"
            ),
            VulnerabilityPattern(
                function_name="fgets",
                vulnerability_type=VulnerabilityType.BUFFER_OVERFLOW,
                risk_level=0.05,
                context_required=["newline_handling"],
                description="Bounded line input",
                example_vulnerable="fgets(buf, size, stdin); // may include newline",
                example_safe="if (fgets(buf, size, stdin)) { len = strlen(buf); if (buf[len-1] == '\\n') buf[len-1] = '\\0'; }"
            ),
            VulnerabilityPattern(
                function_name="strncat",
                vulnerability_type=VulnerabilityType.BUFFER_OVERFLOW,
                risk_level=0.2,
                context_required=["available_space_calculation"],
                description="Bounded string concatenation",
                example_vulnerable="strncat(dest, src, n); // n should be available space",
                example_safe="strncat(dest, src, sizeof(dest) - strlen(dest) - 1);"
            ),
            
            # SAFE MEMORY FUNCTIONS
            VulnerabilityPattern(
                function_name="calloc",
                vulnerability_type=VulnerabilityType.UNINITIALIZED_MEMORY,
                risk_level=0.1,
                context_required=["overflow_check"],
                description="Zero-initialized allocation",
                example_vulnerable="calloc(nmemb, size); // potential integer overflow",
                example_safe="if (nmemb && size > SIZE_MAX/nmemb) return NULL; return calloc(nmemb, size);"
            ),
        ]
    
    def _build_mitigation_patterns(self) -> List[MitigationPattern]:
        """Build list of mitigation patterns and safe alternatives"""
        return [
            MitigationPattern(
                safe_function="strlcpy",
                replaces_vulnerable=["strcpy", "strncpy"],
                mitigation_type="replacement",
                effectiveness=0.95,
                description="BSD strlcpy - always null terminates and returns intended length"
            ),
            MitigationPattern(
                safe_function="strlcat",
                replaces_vulnerable=["strcat", "strncat"],
                mitigation_type="replacement", 
                effectiveness=0.95,
                description="BSD strlcat - always null terminates"
            ),
            MitigationPattern(
                safe_function="reallocarray",
                replaces_vulnerable=["realloc", "calloc"],
                mitigation_type="replacement",
                effectiveness=0.9,
                description="OpenBSD reallocarray - checks for integer overflow"
            ),
            MitigationPattern(
                safe_function="explicit_bzero",
                replaces_vulnerable=["memset"],
                mitigation_type="replacement",
                effectiveness=0.9,
                description="Guaranteed memory clearing that won't be optimized away"
            ),
            MitigationPattern(
                safe_function="arc4random_uniform",
                replaces_vulnerable=["rand", "random"],
                mitigation_type="replacement",
                effectiveness=0.95,
                description="Cryptographically secure random with uniform distribution"
            ),
        ]
    
    def _build_library_mitigations(self) -> Dict[str, List[str]]:
        """Build mapping of security libraries and their safe functions"""
        return {
            # Microsoft Security Development Lifecycle
            "microsoft_sdl": [
                "strcpy_s", "strncpy_s", "strcat_s", "strncat_s",
                "sprintf_s", "snprintf_s", "scanf_s", "gets_s"
            ],
            
            # GNU C Library extensions
            "glibc_secure": [
                "__strcpy_chk", "__strncpy_chk", "__strcat_chk",
                "__sprintf_chk", "__snprintf_chk", "__memcpy_chk"
            ],
            
            # OpenBSD secure functions
            "openbsd_secure": [
                "strlcpy", "strlcat", "reallocarray", "explicit_bzero",
                "arc4random", "arc4random_uniform", "arc4random_buf"
            ],
            
            # Intel MPX (Memory Protection Extensions)
            "intel_mpx": [
                "__bnd_store_ptr_bounds", "__bnd_chk_ptr_bounds",
                "__bnd_copy_ptr_bounds", "__bnd_init_ptr_bounds"
            ],
            
            # AddressSanitizer functions
            "asan": [
                "__asan_report_error", "__asan_check_global",
                "__asan_poison_memory_region", "__asan_unpoison_memory_region"
            ],
            
            # Safe C Library (ISO/IEC TR 24731)
            "safe_c_lib": [
                "memcpy_s", "memmove_s", "memset_s", "strncpy_s", 
                "strncat_s", "strnlen_s", "strtok_s"
            ]
        }
    
    def get_vulnerability_risk(self, function_name: str, context: List[str] = None) -> Tuple[float, VulnerabilityType]:
        """Get vulnerability risk score for a function call"""
        if context is None:
            context = []
            
        # Check vulnerable patterns
        for pattern in self.vulnerable_patterns:
            if pattern.function_name == function_name:
                # Adjust risk based on context
                risk = pattern.risk_level
                if pattern.context_required:
                    context_match = sum(1 for req in pattern.context_required if req in context)
                    context_factor = context_match / len(pattern.context_required)
                    risk *= (0.3 + 0.7 * context_factor)  # Base 30% risk, up to 100% with full context
                return risk, pattern.vulnerability_type
        
        # Check safe patterns
        for pattern in self.safe_patterns:
            if pattern.function_name == function_name:
                return pattern.risk_level, pattern.vulnerability_type
                
        # Check library mitigations
        for lib, functions in self.library_mitigations.items():
            if function_name in functions:
                return 0.1, VulnerabilityType.BUFFER_OVERFLOW  # Assume low risk for secure libs
                
        return 0.3, VulnerabilityType.BUFFER_OVERFLOW  # Unknown function, moderate risk
    
    def get_mitigation_suggestions(self, vulnerable_function: str) -> List[MitigationPattern]:
        """Get mitigation suggestions for a vulnerable function"""
        suggestions = []
        for mitigation in self.mitigation_patterns:
            if vulnerable_function in mitigation.replaces_vulnerable:
                suggestions.append(mitigation)
        return suggestions
    
    def analyze_code_context(self, code_snippet: str) -> List[str]:
        """Analyze code context to determine vulnerability conditions"""
        context = []
        
        # Check for user input sources
        user_input_patterns = [
            r'argv\[', r'gets\(', r'fgets\(.+stdin', r'scanf\(',
            r'getenv\(', r'recv\(', r'read\(.*stdin'
        ]
        if any(re.search(pattern, code_snippet) for pattern in user_input_patterns):
            context.append("user_input")
            
        # Check for unchecked operations
        if re.search(r'(strcpy|sprintf|strcat)\s*\([^)]*\)', code_snippet):
            if not re.search(r'(strlen|sizeof|strnlen)', code_snippet):
                context.append("unchecked_source")
                
        # Check for bounds validation
        if re.search(r'if\s*\([^)]*(<|>|<=|>=)[^)]*\)', code_snippet):
            context.append("bounds_check")
        else:
            context.append("no_bounds_check")
            
        # Check for null pointer checks
        if re.search(r'if\s*\([^)]*!=\s*NULL\)', code_snippet):
            context.append("null_check")
        elif re.search(r'if\s*\([^)]*\)', code_snippet):
            context.append("missing_null_check")
            
        # Check for error handling
        if re.search(r'(return\s+-1|exit\(|abort\()', code_snippet):
            context.append("error_handling")
            
        return context

# Global instance
VULNERABILITY_DB = VulnerabilityPatternDatabase()